# 移动端 Cursor 模式后台挂起导致任务中断 — 方案分析

## 一、问题现象

在移动端使用 Cursor 模式时，若将页面挂起/切到后台（例如切到其他 App 或锁屏），再回到页面时：

- 当前 Agent 任务被中断
- 流式输出停止，界面显示不完整或报错

## 二、当前架构与根因

### 2.1 数据流

1. **前端**（`CursorChatPanel.tsx`）
   - 使用 `fetch("/api/cursor-agent/stream", …)` 发起 POST，用 `resp.body.getReader()` 消费 NDJSON 流
   - 使用 `AbortController` 仅用于用户主动取消（如「新对话」）

2. **后端**（`index.ts` → `cursorAgent.ts`）
   - POST 时调用 `spawnCursorAgentStream()` 启动 Cursor CLI 子进程
   - 将子进程 stdout/stderr 通过 `res.write()` 推给当前 HTTP 响应
   - **关键**：在 `req.on("close")` 里调用 `stop()`，即**一旦客户端断开就杀掉 Agent 进程**

### 2.2 根因归纳

| 层级 | 现象 | 根因 |
|------|------|------|
| **浏览器** | 切后台后 Tab 被挂起/限频 | 系统为省电会冻结或限制后台 JS/网络，fetch 流可能不再被读取或连接被系统关闭 |
| **连接** | 服务器看到「客户端断开」 | 移动端挂起或网络切换时 TCP 断开，Express 触发 `req.on("close")` |
| **服务端** | Agent 被立刻终止 | 当前逻辑：`req.on("close")` → `stop()`，导致子进程被 kill |

因此：**只要连接断开（包括因切后台导致的断开），服务端就会主动结束任务**，这是任务在移动端「一挂起就断」的直接原因。

---

## 三、方案概览

| 方案 | 思路 | 复杂度 | 效果 | 推荐度 |
|------|------|--------|------|--------|
| **A** | 客户端断开时不杀进程 + 输出缓冲 + 重连拉取 | 中高 | 切后台再回来可继续看输出直至任务结束 | ⭐⭐⭐ 推荐 |
| **B** | 仅不杀进程，不缓冲不重连 | 低 | 任务在后台继续跑，但回来看不到新输出 | ⭐ 仅作过渡 |
| **C** | 完全依赖 Cursor Cloud Agent（`&` 任务） | 低 | 需改用户习惯，且依赖 Cursor 云端 | ⭐ 可选 |
| **D** | 仅前端 Visibility + 不 abort | 低 | 无法解决连接被系统断开的问题 | ⭐ 需配合 A |

下面按推荐顺序展开。

---

## 四、方案 A：不断开杀进程 + 输出缓冲 + 重连（推荐）

### 4.1 思路

- **服务端**：客户端断开时**不再**调用 `stop()`，让 Agent 按原有超时/正常结束逻辑继续跑；同时把本次运行的所有 NDJSON 输出写入「按 runId 的缓冲区」。
- **重连**：提供「按 runId 拉取历史 + 后续新输出」的接口（例如 GET 流或 SSE），前端在从后台回到前台且发现原流已断时，用 runId 重新拉取并追齐内容。

这样：  
切后台 → 连接断 → 服务端只断开该响应的写入，不杀进程；  
回到前台 → 前端用 runId 重连 → 先拿到已缓冲的输出，再接到后续输出，直到任务结束。

### 4.2 服务端改动要点

1. **运行实例管理**
   - 每次 POST `/api/cursor-agent/stream` 生成唯一 `runId`（如 UUID），在响应头或首行返回给前端。
   - 内存结构：`Map<runId, { child, stop, buffer: string[], listeners: Set<WritableResponse> }>`。
   - 子进程每行输出：先 push 到 `buffer`，再向当前所有 `listeners` 的 response 写同一行。

2. **POST 行为**
   - 创建 run、启动 Agent、把当前 `res` 加入该 run 的 `listeners`，并开始往 `res` 和 `buffer` 写数据。
   - **`req.on("close")`**：只从 `listeners` 里移除当前 `res`，**不**调用 `stop()`。
   - 进程结束（`onExit`）：给所有 listeners 写结束帧并关闭；从 Map 里删掉 run；可选一段时间后清理 buffer（或持久化到 DB）。

3. **新接口：重连 / 追尾**
   - 例如：`GET /api/cursor-agent/stream/:runId` 或 `POST /api/cursor-agent/attach` body `{ runId }`。
   - 若 run 存在：先把 `buffer` 里已有行按顺序写给该连接，再把该连接的 `res` 加入 `listeners`，后续与其它 listener 一样收到新输出直到 run 结束。
   - 若 run 已结束：可直接返回 buffer 全量（或最后 N 条）加结束标记，无需长连接。

4. **资源与超时**
   - 沿用现有「无输出 N 分钟则杀进程」的 inactivity 超时，避免僵尸进程。
   - 可选：若某 run 已结束且超过一定时间无人拉取，再清理 buffer，避免内存无限增长。

### 4.3 前端改动要点

1. **保存 runId**
   - 从首条响应或响应头里解析出 `runId`，存到 state/ref（例如与当前 chat/session 绑定）。

2. **从后台恢复时重连**
   - 使用 **Page Visibility API**（`document.visibilityState` / `visibilitychange`）：
     - 当从 `hidden` 变为 `visible` 时，若当前处于「正在跑 Agent」且原 fetch 流已不可用（例如 `reader` 报错或已 closed），则用保存的 `runId` 调用上述重连接口。
   - 重连拿到的是「历史缓冲 + 后续实时」：先重放已有内容到 UI，再继续追加新行，逻辑可复用现有 `handleEvent`。

3. **不因切后台主动 abort**
   - 切到后台时不要调用 `AbortController.abort()`，仅在前台用户点击「停止」「新对话」等时再 abort。这样可减少「自己主动断流」导致的断线。

### 4.4 优缺点

- **优点**：任务在后台继续执行，回到前台能接上输出，体验接近「挂起不中断」；与现有 Cursor CLI 的 `--resume` 无强耦合，可先做缓冲+重连，后续再考虑 resume。
- **缺点**：需维护 run 与 buffer、多 listener 写入、超时与清理逻辑，实现和测试量相对大。

---

## 五、方案 B：仅不断开杀进程（不缓冲、不重连）

### 5.1 思路

- 只改服务端：`req.on("close")` 时**不**调用 `stop()`，仅结束向该 `res` 的写入并移除引用。
- 不引入 buffer、runId、重连接口。

### 5.2 效果与局限

- **效果**：切后台导致连接断开后，Agent 仍在服务器上跑到结束或 inactivity 超时，不会因为「用户切到后台」而被杀。
- **局限**：用户再回到页面时，当前这条 HTTP 流已经断了，没有新接口可拉取未看到的输出，所以**界面上看不到后续进展**，只能通过「新对话 / 同一会话再发一条」等方式间接知道任务已跑完（若后端有其它状态或日志）。

适合作为**最小改动、先保证任务不被误杀**的过渡；若要「回来还能接着看」，必须配合方案 A 的缓冲与重连。

---

## 六、方案 C：引导使用 Cursor Cloud Agent（`&`）

### 6.1 思路

- 在 UI/文案中引导用户在「可能切后台」的场景下，使用 Cursor CLI 的 Cloud Agent：在输入前加 `&`，例如 `& 实现 xxx 功能`，任务会到 Cursor 云端执行。
- 用户在 `cursor.com/agents`（含移动端）上查看进度和结果。

### 6.2 优缺点

- **优点**：无需改现有服务端流式架构；云端本身适合长时间、可随时离开再看的任务。
- **缺点**：依赖 Cursor 账号与云端；用户需要改变输入习惯；和「在当前 VibeGo 里连续看流式输出」的体验不同。可作为**补充**说明，而不是替代方案 A。

---

## 七、方案 D：仅前端 Visibility + 不 abort

### 7.1 思路

- 监听 `visibilitychange`，在变为 `hidden` 时不调用 `AbortController.abort()`，避免前端主动取消请求。
- 不改服务端。

### 7.2 局限

- 移动端切后台时，**系统或浏览器仍可能关闭/挂起 TCP 连接**，服务端依然会收到 `req.on("close")` 并执行 `stop()`。因此单靠「不 abort」无法避免任务被终止，只能作为方案 A 的前端配合手段（避免无谓的主动断流）。

---

## 八、推荐实施顺序

1. **短期**  
   - 采用 **方案 B**：去掉「客户端断开即杀进程」的逻辑，让任务在后台至少能跑完（即使用户暂时看不到后续输出）。  
   - 可选：加上 **方案 D**（切后台不 abort），为后续重连减少干扰。

2. **中期**  
   - 实施 **方案 A**：runId、缓冲、`req.on("close")` 只移除 listener、以及重连接口 + 前端 visibility 重连与重放。这样移动端「挂起再回来」也能继续看到输出直至任务结束。

3. **补充**  
   - 在帮助或提示里加入 **方案 C**（`&` Cloud Agent），作为「长时间、可离开」场景的推荐用法。

---

## 九、小结

| 问题 | 原因 |
|------|------|
| 为什么一切后台就断？ | 连接断开后，服务端 `req.on("close")` 会 `stop()` 杀进程。 |
| 移动端为何容易断？ | 系统/浏览器对后台 Tab 限网、挂起，导致 TCP 断开。 |

| 推荐做法 | 说明 |
|----------|------|
| 必做（服务端） | 客户端断开时**不**杀 Agent，仅断开该响应的写入；可选先做方案 B，再升级到带缓冲+重连的方案 A。 |
| 必做（方案 A 完整版） | 为每次运行分配 runId、缓冲输出、提供按 runId 重连接口；前端在从后台回到前台时用 runId 重连并重放缓冲。 |
| 前端配合 | 切后台不 abort（方案 D）；若实现方案 A，则在 visibility 恢复时检测断流并用 runId 重连。 |
| 可选 | 在文档/UI 中推荐 Cursor Cloud Agent（`&`）用于「可离开再看」的长任务。 |

按上述顺序实施，即可在不大改 Cursor CLI 本身的前提下，解决移动端「页面挂起导致任务中断」的问题，并逐步做到「挂起再回来还能接着看输出」。
